#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11"
# dependencies = [
#   "httpx",
# ]
# ///
"""
git-smart-commit: Analyze unstaged changes, group into logical commits, execute them.

Uses Qwen3-Coder-30B-A3B via Ollama for classification.

Usage:
    git-smart-commit [--repo PATH] [--dry-run] [--model MODEL] [--yes]

Options:
    --repo PATH     Path to git repository (default: current directory)
    --dry-run       Print proposed commits without executing
    --model MODEL   Ollama model to use (default: qwen2.5-coder:32b)
    --yes           Skip confirmation prompt and commit immediately
    --json          Output proposed commits as JSON and exit (implies --dry-run)
    --help          Show this message

Exit codes:
    0   Success
    1   No changes found
    2   Model/Ollama error
    3   Git error
    4   User cancelled
"""

import argparse
import json
import subprocess
import sys
import textwrap
from pathlib import Path

import httpx

# ── Configuration ──────────────────────────────────────────────────────────────

OLLAMA_BASE_URL = "http://localhost:11434"
DEFAULT_MODEL = "qwen3-coder:30b-a3b-q8_0"
OLLAMA_TIMEOUT = 300.0
NUM_CTX = 32768  # classification prompt is tiny with --stat approach

# ── Git helpers ────────────────────────────────────────────────────────────────

def git(args: list[str], cwd: Path) -> str:
    """Run a git command and return stdout. Raises on non-zero exit."""
    result = subprocess.run(
        ["git"] + args,
        cwd=cwd,
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        raise RuntimeError(f"git {' '.join(args)} failed:\n{result.stderr.strip()}")
    return result.stdout


def get_changed_files(repo: Path) -> list[str]:
    """Return list of files with unstaged or staged changes."""
    # Both staged (cached) and unstaged, deduped
    staged = git(["diff", "--cached", "--name-only"], repo).splitlines()
    unstaged = git(["diff", "--name-only"], repo).splitlines()
    untracked = git(["ls-files", "--others", "--exclude-standard"], repo).splitlines()
    seen = set()
    files = []
    for f in staged + unstaged + untracked:
        if f and f not in seen:
            seen.add(f)
            files.append(f)
    return files


def build_stat_summary(repo: Path) -> str:
    """Return git diff --stat for staged+unstaged changes.

    This is the classification pass input — one compact line per file showing
    what changed (insertions/deletions), not the full patch. Keeps the prompt
    tiny regardless of diff size.
    """
    # Combine staged and unstaged stat output
    staged_stat = git(["diff", "--cached", "--stat", "--no-color"], repo).strip()
    unstaged_stat = git(["diff", "--stat", "--no-color"], repo).strip()
    untracked = git(["ls-files", "--others", "--exclude-standard"], repo).splitlines()

    parts = []
    if staged_stat:
        parts.append(f"Staged:\n{staged_stat}")
    if unstaged_stat:
        parts.append(f"Unstaged:\n{unstaged_stat}")
    if untracked:
        parts.append("Untracked (new files):\n" + "\n".join(f"  {f}" for f in untracked))
    return "\n\n".join(parts)


# ── Ollama client ──────────────────────────────────────────────────────────────

def call_ollama(model: str, prompt: str) -> str:
    """Call Ollama chat completions and return the assistant message text."""
    payload = {
        "model": model,
        "messages": [{"role": "user", "content": prompt}],
        "stream": True,
        "keep_alive": "1h",
        "options": {
            "temperature": 0.1,   # low temp for deterministic classification
            "num_ctx": NUM_CTX,
        },
    }
    # try:
    with httpx.Client(timeout=httpx.Timeout(connect=30.0, read=60.0, write=30.0, pool=5.0)) as client:
        with client.stream("POST", f"{OLLAMA_BASE_URL}/api/chat", json=payload) as response:
            response.raise_for_status()
            chunks = []
            for line in response.iter_lines():
                if not line:
                    continue
                try:
                    data = json.loads(line)
                except json.JSONDecodeError:
                    continue
                content = data.get("message", {}).get("content", "")
                if content:
                    chunks.append(content)
                if data.get("done"):
                    break
            return "".join(chunks)
    #except httpx.ConnectError:
    #    print("Error: Cannot connect to Ollama. Is it running? (ollama serve)", file=sys.stderr)
    #    sys.exit(2)
    #except httpx.HTTPStatusError as e:
    #    try:
    #        body = e.response.read().decode()
    #    except Exception:
    #        body = "(unreadable)"
    #    print(f"Error: Ollama returned {e.response.status_code} for {e.request.url}: {body}", file=sys.stderr)
    #    sys.exit(2)


# ── Classification prompt ──────────────────────────────────────────────────────

SYSTEM_PROMPT = textwrap.dedent("""\
    You are a senior software engineer helping organize messy working-tree changes
    into clean, logical git commits.

    Given a list of changed files and their diffs, your job is to group them into
    one or more commits. Each commit should represent a single logical change
    (e.g. "add feature X", "fix bug in Y", "update dependencies", "refactor Z").

    You do not need to commit every file: if a file is junk, just
    leave it unstaged and do not commit it.

    Rules:
    - Keep related changes together (same feature, same module, same concern)
    - Separate unrelated concerns into different commits
    - Dependency/lockfile changes belong with the commit that caused them
    - Test files belong with the code they test
    - Use conventional commit format for messages:
       ```
       type(scope): short description

       long description
       ```
      Types: feat, fix, refactor, chore, docs, test, style, build, ci
    - Keep short description concise (under 72 chars)
    - Make long description relatively brief but informative (4-10 lines, wrapped at 80 chars, markdown format)
    - Identify junk files from editors and the build process and do not include them but suggest .gitignore patterns

    Respond ONLY with a JSON array. No prose, no markdown fences. Example:
    [
      {
        "message": "feat(auth): add JWT refresh token support",
        "files": ["src/auth/refresh.py", "tests/test_refresh.py"]
      },
      {
        "message": "chore(deps): bump httpx to 0.27",
        "files": ["requirements.txt", "poetry.lock"]
      }
    ]
""")


def classify_changes(model: str, files: list[str], stat_summary: str) -> list[dict]:
    """Ask the model to group files into logical commits. Returns list of commit dicts."""
    file_list = "\n".join(f"  - {f}" for f in files)
    prompt = (
        f"{SYSTEM_PROMPT}\n\n"
        f"Changed files:\n{file_list}\n\n"
        f"Change summary (git diff --stat):\n{stat_summary}"
    )

    raw = call_ollama(model, prompt)

    # Strip any accidental markdown fences the model might add
    raw = raw.strip()
    if raw.startswith("```"):
        lines = raw.splitlines()
        raw = "\n".join(lines[1:-1] if lines[-1].strip() == "```" else lines[1:])

    try:
        commits = json.loads(raw)
    except json.JSONDecodeError as e:
        print(f"Error: Model returned invalid JSON: {e}", file=sys.stderr)
        print(f"Raw output:\n{raw}", file=sys.stderr)
        sys.exit(2)

    if not isinstance(commits, list):
        print("Error: Model returned unexpected structure (expected a JSON array).", file=sys.stderr)
        sys.exit(2)

    # Validate each entry
    valid = []
    for item in commits:
        if isinstance(item, dict) and "message" in item and "files" in item:
            valid.append(item)
    if not valid:
        print("Error: Model returned no valid commit groups.", file=sys.stderr)
        sys.exit(2)

    return valid


# ── Commit execution ───────────────────────────────────────────────────────────

def execute_commits(repo: Path, commits: list[dict]) -> None:
    """Stage and commit each group in order."""
    for i, commit in enumerate(commits, 1):
        message = commit["message"]
        files = commit["files"]

        print(f"\n[{i}/{len(commits)}] {message}")

        # Stage the files for this commit
        for f in files:
            try:
                git(["add", "--", f], repo)
                print(f"  + {f}")
            except RuntimeError as e:
                print(f"  ! Could not stage {f}: {e}", file=sys.stderr)

        # Check something is actually staged
        staged = git(["diff", "--cached", "--name-only"], repo).strip()
        if not staged:
            print("  (nothing staged, skipping)")
            continue

        try:
            git(["commit", "-m", message], repo)
            print(f"  ✓ Committed")
        except RuntimeError as e:
            print(f"  Error committing: {e}", file=sys.stderr)
            sys.exit(3)


# ── Display helpers ────────────────────────────────────────────────────────────

def print_proposed_commits(commits: list[dict]) -> None:
    print("\nProposed commits:")
    print("─" * 60)
    for i, commit in enumerate(commits, 1):
        print(f"\n  [{i}] {commit['message']}")
        for f in commit.get("files", []):
            print(f"       {f}")
    print()


# ── Main ───────────────────────────────────────────────────────────────────────

def main() -> None:
    parser = argparse.ArgumentParser(
        description="Group git changes into logical commits using Qwen3-Coder.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__,
    )
    parser.add_argument("--repo", default=".", help="Path to git repository")
    parser.add_argument("--dry-run", action="store_true", help="Show proposed commits without executing")
    parser.add_argument("--model", default=DEFAULT_MODEL, help=f"Ollama model (default: {DEFAULT_MODEL})")
    parser.add_argument("--yes", "-y", action="store_true", help="Commit without confirmation")
    parser.add_argument("--json", dest="json_out", action="store_true", help="Output JSON and exit")

    args = parser.parse_args()
    repo = Path(args.repo).resolve()

    # Verify it's a git repo
    try:
        git(["rev-parse", "--git-dir"], repo)
    except RuntimeError:
        print(f"Error: {repo} is not a git repository.", file=sys.stderr)
        sys.exit(3)

    # Collect changed files
    print("Scanning for changes...", file=sys.stderr)
    files = get_changed_files(repo)
    if not files:
        print("No changes found.", file=sys.stderr)
        sys.exit(1)

    print(f"Found {len(files)} changed file(s). Analyzing...", file=sys.stderr)

    # Build stat summary and classify
    stat_summary = build_stat_summary(repo)
    commits = classify_changes(args.model, files, stat_summary)

    # JSON mode: just dump and exit
    if args.json_out:
        print(json.dumps(commits, indent=2))
        return

    # Display proposed commits
    print_proposed_commits(commits)

    if args.dry_run:
        return

    # Confirm unless --yes
    if not args.yes:
        try:
            answer = input("Proceed with these commits? [y/N] ").strip().lower()
        except (KeyboardInterrupt, EOFError):
            print("\nCancelled.")
            sys.exit(4)
        if answer not in ("y", "yes"):
            print("Cancelled.")
            sys.exit(4)

    execute_commits(repo, commits)
    print("\nDone.")


if __name__ == "__main__":
    main()
